# Изучение сценариев командной строки

Подготовил: **Полушвайко Константин Николаевич**

## Специальные символы
### Экранирование
Для **экранирования** используется `\`.
> Экранирование символов — замена в тексте управляющих символов на соответствующие текстовые подстановки.

> #### Дополнительная информация
> `".."` Двойные кавычки, отменяют действие спецсимволов кроме $ \`..\` и \\.
>
> `'...'` Апострофы, отменяют действие всех спецсимволов в том числе и \\, по этому нельзя включить апостроф в строку ограниченную апострофами.

### Комментарии
Для **комментариев** используется `#`.

### Перенаправление ввода/вывода
`>` - перенаправление стандартного вывода программы в файл (для дозаписи используется `>>`).

`<` - перенаправление стандартного ввода программы из файла.
`<<TERM` перенаправление стандартного ввода программы из текста текущего скрипта со следующей строки до строки, состоящей из слова `TERM`.

`|` - перенаправление стандартного вывода программы на стандартный ввод другой программы

> #### Дополнительная информация
> `:` - Нулевая команда, всегда возвращает нулевой код ответа *(также является эквивалентом `true`)*. В сочетании с перенаправлением `>` создает файл, или обнуляет существующий. В сочетании с перенаправлением `>>` создает файл, или изменяет время модификации существующего.

### Разделитель команд
Для **последовательного выполнения** команд используется `;` между операторами.
> `;;` - Разделитель альтернатив в операторе case.

###### `terminal`
```bash
$ mkdir folderName; cd folderName; touch fileName
```
> Создаем директорию `folderName`, переходим в нее и создаем файл `fileName`.

### Выполнение при успехе
Для последовательного выполнения команд, если **предыдущий** оператор **выполнился успешно** используется `&&`.

###### `terminal`
```bash
$ cd folderName && touch fileName
```
> Пытаемся перейти в папку `folderName`, если получилось, то создаем файл `fileName`.

### Выполнение при провале
Для последовательного выполнения команд, если **предыдущий** оператор **выполнился неудачно** используется `||`.

###### `terminal`
```bash
$ cd folderName || mkdir folderName
```
> Пытаемся перейти в папку `folderName`, если НЕ получилось, то создаем директорию `folderName`.

### Включение файла в скрипт
`.` - Аналог команды `source` (#include в С++). Выполняет скрипт в текущем интерпретаторе. (Например, `. myconf` или `. .env`).
###### `sourceExample.sh`
```bash
#!/bin/bash
# Создаем переменную файла
SOURCE=.env

# Включаем данный файл
. $SOURCE

# Проверка на ошибку включение (есть ли такой файл)
if [ $? -ne 0 ]; then
    echo "Не удалось открыть $SOURCE"
    exit 1
fi

# Выводим переменную из файла
echo $VAR
```

### Шаблоны 
Шаблоны в именах файлов. Если подходящие имена находятся, то они подставляются в командную строку как отдельные аргументы *(возможно с пробелами внутри)*. Если имена не находятся, то шаблон остается как есть.

`*` - Шаблон заменяющий любую последовательность символов.

`?` - Шаблон заменяющий ровно один символ.

`[xyz]` - Шаблон заменяющий один из перечисленных символов.

`{xxx,yyy,zzz,...}` - Подстановка одного из вариантов в шаблон. В скобках не должно быть неэкранированных пробелов.

###### `terminal`
```bash
$ grep Linux file*.{txt,htm*} 
# Ищет слово “Linux” в файлах вида “fileA.txt”, “file2.txt”, “fileR.html”, “file-87.htm”, etc.
```

## Шебанг *(shebang)*
**Шебанг** *(или Магическая строка)* - это специальный комментарий `#!`, который указывает на то, какой интерпретатор использовать для выполнения скрипта, если при вызове скрипта не был явно указан интерпретатор.

### Пример 1
Файл [`script.py`](#scriptpy) содержит:

###### `script.py`
```python
# Используем шебанг для интерпретатора python
#!/usr/bin/env python

a = 5
b = 7

print(a + b)
```

Запускаем скрипт [`script.py`](#scriptpy) сначала без явного указания интерпретатора, затем с явным указанием python, и еще раз, но с явным указанием интерпретатора bash:

###### `terminal`
```bash
$ ./script.py 
12

$ python script.py 
12

$ bash script.py 
script.py: line 3: a: command not found
script.py: line 4: b: command not found
script.py: line 6: syntax error near unexpected token `a'
script.py: line 6: `print(a + b)'
```

Из примера видно, что шебанг используется для удобства запуска скриптов, а также указывает на нужный интерпретатор для скрипта.

# Разделы в разработке

## Констукция if-elif-else
```bash
if [ условие ]
then
  команды
elif [ другое условие ]
then
  другие команды
else
  команды по умолчанию
fi
```
> А можно и так:
>```bash
>if [ условие ]; then команды; elif [ другое условие ]; then другие команды; else команды по умолчанию fi 
>```

## Констукция case
```bash
case выражение in
  шаблон1)
    команды1
    ;;
  шаблон2)
    команды2
    ;;
  *)
    команды по умолчанию
    ;;
esac
```

## Операторы условного выражения

### Сравнение чисел:
- `-eq`: равно
- `-ne`: не равно
- `-lt`: меньше
- `-le`: меньше или равно
- `-gt`: больше
- `-ge`: больше или равно

### Сравнение строк:
- `=:` равно
- `!=`: не равно
- `-z`: строка пустая
- `-n`: строка не пустая

### Проверка файлов:
- `-e`: файл существует
- `-f`: файл существует и это регулярный файл
- `-d`: файл существует и это директория
- `-r`: файл существует и доступен для чтения
- `-w`: файл существует и доступен для записи
- `-x`: файл существует и доступен для выполнения